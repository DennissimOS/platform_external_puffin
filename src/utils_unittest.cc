// Copyright 2017 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <vector>

#include "gtest/gtest.h"

#include "puffin/src/include/puffin/common.h"
#include "puffin/src/include/puffin/utils.h"
#include "puffin/src/memory_stream.h"
#include "puffin/src/unittest_common.h"

namespace puffin {

using std::vector;

namespace {
const uint8_t kZipEntries[] = {
    0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x02, 0x00, 0x08, 0x00, 0xfc, 0x88,
    0x28, 0x4c, 0xcb, 0x86, 0xe1, 0x80, 0x06, 0x00, 0x00, 0x00, 0x09, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x1c, 0x00, 0x31, 0x55, 0x54, 0x09, 0x00, 0x03,
    0xec, 0x15, 0x54, 0x5a, 0x49, 0x10, 0x54, 0x5a, 0x75, 0x78, 0x0b, 0x00,
    0x01, 0x04, 0x8f, 0x66, 0x05, 0x00, 0x04, 0x88, 0x13, 0x00, 0x00, 0x33,
    0x34, 0x84, 0x00, 0x2e, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x02,
    0x00, 0x08, 0x00, 0x01, 0x89, 0x28, 0x4c, 0xe0, 0xe8, 0x6f, 0x6d, 0x06,
    0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x1c, 0x00, 0x32,
    0x55, 0x54, 0x09, 0x00, 0x03, 0xf1, 0x15, 0x54, 0x5a, 0x38, 0x10, 0x54,
    0x5a, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0x8f, 0x66, 0x05, 0x00, 0x04,
    0x88, 0x13, 0x00, 0x00, 0x33, 0x32, 0x82, 0x01, 0x2e, 0x00};

// (echo "666666" > 2 && zip -fd test.zip 2 &&
//  cat test.zip | hexdump -v -e '10/1 "0x%02x, " "\n"')
const uint8_t kZipEntryWithDataDescriptor[] = {
    0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x00, 0x08, 0x00, 0x0b, 0x74,
    0x2b, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x1c, 0x00, 0x32, 0x55, 0x54, 0x09, 0x00, 0x03,
    0xf5, 0xe5, 0x57, 0x5a, 0xf2, 0xe5, 0x57, 0x5a, 0x75, 0x78, 0x0b, 0x00,
    0x01, 0x04, 0x8f, 0x66, 0x05, 0x00, 0x04, 0x88, 0x13, 0x00, 0x00, 0x33,
    0x33, 0x03, 0x01, 0x2e, 0x00, 0x50, 0x4b, 0x07, 0x08, 0xb4, 0xa0, 0xf2,
    0x36, 0x06, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x50, 0x4b, 0x03,
    0x04, 0x14, 0x00, 0x08, 0x00, 0x08, 0x00, 0x0b, 0x74, 0x2b, 0x4c, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x1c, 0x00, 0x32, 0x55, 0x54, 0x09, 0x00, 0x03, 0xf5, 0xe5, 0x57,
    0x5a, 0xf2, 0xe5, 0x57, 0x5a, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0x8f,
    0x66, 0x05, 0x00, 0x04, 0x88, 0x13, 0x00, 0x00, 0x33, 0x33, 0x03, 0x01,
    0x2e, 0x00, 0xb4, 0xa0, 0xf2, 0x36, 0x06, 0x00, 0x00, 0x00, 0x07, 0x00,
    0x00, 0x00};

void FindDeflatesInZlibBlocks(const Buffer& src,
                              const vector<ByteExtent>& zlibs,
                              const vector<BitExtent>& deflates) {
  auto src_stream = MemoryStream::CreateForRead(src);
  vector<BitExtent> deflates_out;
  ASSERT_TRUE(LocateDeflatesInZlibBlocks(src_stream, zlibs, &deflates_out));
  ASSERT_EQ(deflates, deflates_out);
}

void CheckFindPuffLocation(const Buffer& compressed,
                           const vector<BitExtent>& deflates,
                           const vector<ByteExtent>& expected_puffs,
                           size_t expected_puff_size) {
  auto src = MemoryStream::CreateForRead(compressed);
  vector<ByteExtent> puffs;
  size_t puff_size;
  ASSERT_TRUE(FindPuffLocations(src, deflates, &puffs, &puff_size));
  EXPECT_EQ(puffs, expected_puffs);
  EXPECT_EQ(puff_size, expected_puff_size);
}
}  // namespace

TEST(UtilsTest, LocateDeflatesInZlibsTest) {
  Buffer empty;
  vector<ByteExtent> empty_zlibs;
  vector<BitExtent> empty_deflates;
  FindDeflatesInZlibBlocks(empty, empty_zlibs, empty_deflates);
}

// Test Simple Puffing of the source.

TEST(UtilsTest, FindPuffLocations1Test) {
  CheckFindPuffLocation(kDeflates8, kSubblockDeflateExtents8, kPuffExtents8,
                        kPuffs8.size());
}

TEST(UtilsTest, FindPuffLocations2Test) {
  CheckFindPuffLocation(kDeflates9, kSubblockDeflateExtents9, kPuffExtents9,
                        kPuffs9.size());
}

// TODO(ahassani): Test a proper zlib format.
// TODO(ahassani): Test zlib format with wrong header.

TEST(UtilsTest, LocateDeflatesInZipArchiveSmoke) {
  Buffer zip_entries(kZipEntries, std::end(kZipEntries));
  vector<ByteExtent> deflates;
  EXPECT_TRUE(LocateDeflatesInZipArchive(zip_entries, &deflates));
  EXPECT_EQ(static_cast<size_t>(2), deflates.size());
  EXPECT_EQ(ByteExtent(59, 6), deflates[0]);
  EXPECT_EQ(ByteExtent(124, 6), deflates[1]);
}

TEST(UtilsTest, LocateDeflatesInZipArchiveWithDataDescriptor) {
  Buffer zip_entries(kZipEntryWithDataDescriptor,
                     std::end(kZipEntryWithDataDescriptor));
  vector<ByteExtent> deflates;
  EXPECT_TRUE(LocateDeflatesInZipArchive(zip_entries, &deflates));
  EXPECT_EQ(static_cast<size_t>(2), deflates.size());
  EXPECT_EQ(ByteExtent(59, 6), deflates[0]);
  EXPECT_EQ(ByteExtent(140, 6), deflates[1]);
}

TEST(UtilsTest, LocateDeflatesInZipArchiveErrorChecks) {
  Buffer zip_entries(kZipEntries, std::end(kZipEntries));
  // Construct a invalid zip entry whose size overflows.
  zip_entries[29] = 0xff;
  vector<ByteExtent> deflates_overflow;
  EXPECT_TRUE(LocateDeflatesInZipArchive(zip_entries, &deflates_overflow));
  EXPECT_EQ(static_cast<size_t>(1), deflates_overflow.size());
  EXPECT_EQ(ByteExtent(124, 6), deflates_overflow[0]);

  zip_entries.resize(128);
  vector<ByteExtent> deflates_incomplete;
  EXPECT_TRUE(LocateDeflatesInZipArchive(zip_entries, &deflates_incomplete));
  EXPECT_EQ(static_cast<size_t>(0), deflates_incomplete.size());
}

}  // namespace puffin
